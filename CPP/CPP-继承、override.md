
## 继承：
> 在定义一个新的类B时，如果如果该类与某个已有的类A相似（指的是B拥有A的全部特点），那么就可以把A作为一个基类，而把B作为基类的一个派生类。  

## 虚继承
> 虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：
```c++
class A

class B1:public virtual A;

class B2:public virtual A;

class D:public B1,public B2;
```
> 虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。

> 由于有了间接性和共享性两个特征，所以决定了虚继承体系下的对象在访问时必然会在时间和空间上与一般情况有较大不同。
> 1. 时间：在通过继承类对象访问虚基类对象中的成员（包括数据成员和函数成员）时，都必须通过某种间接引用来完成，这样会增加引用寻址时间（就和虚函数一样），其实就是调整this指针以指向虚基类对象，只不过这个调整是运行时间接完成的。
> 2. 空间：由于共享所以不必要在对象内存中保存多份虚基类子对象的拷贝，这样较之多继承节省空间。虚拟继承与普通继承不同的是，虚拟继承可以防止出现diamond继承时，一个派生类中同时出现了两个基类的子对象。也就是说，为了保证这一点，在虚拟继承情况下，基类子对象的布局是不同于普通继承的。**因此，它需要多出一个指向基类子对象的指针**。

## 类之间的两种关系：
> 1. 继承： “是”关系  
    ----- 基类A，B是基类A的派生类  
    ----- 逻辑上要求：“一个B对象也是一个A对象”  
> 2. 复合：“有”关系 （通常也称为封闭类）  
    ------类C中“有”成员变量K，K是类D的对象，则C和D是复合关系。  
    ------一般逻辑上要求：D对象是C对象的固有属性或组成部分。
> NOTE：当成员K并不完全符合继承、复合关系时，可以考虑使用指针，则类之间的关系就变为“指向”。

## Override：
> 派生类可以定义一个和基类成员同名的成员，这叫覆盖(C++允许存在同名的成员变量)。在派生类中访问这类成员时，缺省的情况是访问派生类中定义的成员。要在派生类中访问由基类定义的成员时，需要使用作用域符号:: 。

```c++
class A {
    public:
    int _a;
    A() {
        _a = 1;
    }
    void print() {
        cout << _a;
    }
};

class B : public A {
    public:
    int _a;
    B() {
        _a = 2;
    }
};

int main(int argc, char const *argv[])
{
    B b;
    b.print(); //输出1
    cout << b._a << endl; 
    return 0;
}
```


## 存取访问权限：
> 1. 基类的private成员:  
    ---- 基类的成员函数  
    ---- 基类的友元函数  
> 2. 基类的protected成员:  
    ---- 基类的成员函数  
    ---- 基类的友元函数
    ---- 派生类的成员函数可以访问当前对象的基类的保护成员  

```C++
class Father {
private: int nPrivate; //私有成员
public: int nPublic;  //公有成员
protected: int nProtected; // 保护成员
};

class Son :public Father{
void AccessFather () {
nPublic = 1;
//
nPrivate = 1;
// wrong
nProtected = 1;
// OK ，访问从基类继承的 protected 成员
Son f;
f.nProtected = 1;
//wrong f 不是当前对象
}
};
```
## 调用基类构造函数的两种方式：
> * 显示方式：在派生类的构造函数中（在初始化列表中）为基类的构造函数提供参数。  
    --- derived::derived(arg_list): Base(arg_list)  
> * 隐式方式：在派生类的构造函数中，省略基类构造函数时，派生类的构造函数则自动调用基类的默认构造函数（不存在则必须显示调用）。

**Note：** 当类中含有别的类的成员对象时，也应在初始化列表给出初始化（当无默认构造函数时）。  
X x;   (....): x(arg)
